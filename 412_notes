8/29 (Discussion)

int * const blah --> the pointer cannot be changed
const int *blah  --> the pointer is to a const int
            
consider:
	arr = {1,2,3,4,5}
	a = arr
	c = a
	
	++*a;        --> dereferences a and then increments that value
	*a++         --> dereferences a and then increments the pointer
	*c = (*a)++; --> adds dereferenced c and a, then increments a 

For macros, consider this:
    #define MULT(a,b) (a * b)
    	    --> This does NOT work with MULT(1+2,3+4) OOP
Try instead:
    #define MULT(a,b) ((a) * (b))

gcc -D SAMPLE --> defines the given macro SAMPLE

gcc -E --> will show code after preprocessing

8/30 (Lecture)

intro stuff

8/31 (Discussion)

vagrant up --> initialize vm
vagrant ssh --> get into vm
cd /vagrant is a shared file (really wherever you run VM from becomes the 
 vagrant directory)
 	 you should run vagrant ssh from the project folder
vagrant destroy (you might lose local changes WITHIN the vm not in shared dir)
vagrant halt --> will shutdown VM instance but not remove from disk
	Both use "vagrant up" to start back up
You can run GeekOS from both local machine and VM

kassert can be helpful for finding errors

gdb: watch variable tracks variable changes
     conditional breaks

9/6 (Lecture)

Project 1: Fork and exec

   After fork, we have 2 user processes (user address space)
      Each has a unique Kernel_Thread (KT)
         Each KT has its own Stack -> you must decide what Stack is inherited
            Each KT has a unique userContext (UC)
               Each has an individual set of file descriptors (FD)
	          Each FD points into the same File Descriptor Table (FDT)
      Global variables start out the same, but are updated separately
      EIP is copied into new process
      Spawn (maybe in user.c or userseg.c) has most of what we need	    
      In GEEKOS, no stdin, stdout, stderr

User Process vs. Kernel
   Process believes it has its own CPU
   Process essentially believes there is infinite memory
   Process believes there are "files" and "directories"
   Process believes there is "Wall" between it and other processes
   IPC - Inter-Process-Communication
      pipe, signal, shared memory, message passing, network sockets

Virtual Memory
   Any time the address in a register is different from the physical address
   Can be used to provide illusion of more space
   0xfffffff
   ________
   stack (grows down)
   ________
   heap (grows up)
   ________
   data
   ________
   txt
   ________

   ________
   0x00000000	

   segmentation allows >1 instances of the same program
   nm (executable) -> shows addresses of all symbols in executable
      first usable page starts at 0x1000 because we want 0 to be reserved
      for Null

Pointer Alignment
   (int *) -> should be 4-byte aligned
      should be a multiple of 4
   (char *) -> should be 1-byte aligned
      should be a multiple of 1
   consider:
      struct foo {int a; char b; int c;};
         sizeof(foo) = 12 bytes (not 9 due to int 4-byte alignment)

9/7 (Discussion)

   Project 0:
      Ensure that everything is appropriately freed in Close
         Try a test that repeatedly calls Pipe and Close

   Project 1:
      Mutex will probably be the way to go		
      Take a look at Spawn (in user.c)
         Spawn unsurprisingly Spawns a user process      
      Each process has a kernel_thread associated with it
         Each of these has a user_context
      Jump around k_thread struct and User_Context struct (user.h)
      Also Sys_Spawn -> look here also
      Mutex in sync.c (I think)

   gdb notes:
      run "make dbg run;make dbg"
      b "Sys_Spawn" --> breakpoing at Sys_Spawn function 
      s -> step into
      n -> step over
      c -> keep going till next breakpoint
      printx --> print variable in hex
      struct notation from c still works for print

9/8 (Lecture)

   Project 0: 
      Too much output being printed by students
         try :
            fn() {
      	       static int ive_complain;

	       if (!ive_complained) {
	          Print("waaa!");
	          ive_complained = 1;
	       }
	fixed size buffer:
	   allocate little buffers in a list
	   allocate a single buffer and shift/advance (I shift)
	      advance would probably be better, but I should check changes
	      for shift I should use memmove, not memcpy

   Process States:
      Running:
         to get to Waiting:
	    waiting for input(device)? child process to terminate? mutex?
	 to get to Runnable:
	    dispatcher (I think) can force an active process into the run queue
      Runnable:
         to get to Running:
	    piece of software (dispatcher) pops process off of run queue
      Waiting (Blocked):
         to get to Runnable:
	    when the thing we were waiting for happens
	    (unblocked/awakened from the wait queue)

      for all process in Runnable (on run queue):
         how do we decide which to run?
	 how do we manage the Run Queue?
	    - priorities on processes
	       * most complex last
	       * how long it's been waiting
	          - longer waits first, avoid starvation
	       * how much longer it will run
	          - longer run last, allow short jobs responsive
		  - can we do this? (external spec?, predicter?)
	       * how much resources it will use
	          - can be useful in event of conflict on resources
		  - possible justification to suspend process
	       * solving priority inversion
	          - priority inversion
		     * parent important, calls wait on child
		     * child not important (doesn't fit above criteria)
		     * high priority waiting on low priority
		  - possibly temporarily bump up a low priority process
	       * Avoiding starvation is particularly important
	       * Allowing short commands to be responsive is also important

      Scheduler (three levels):
         long-term scheduling:	
	    deciding which process to run (or really start) 
	       - associated with "batch"
	          * old-school approach when punch cards were a thing
		  * finish one process, move onto the next
		  * as opposed to time-sharing
		     - we start a job whenever we want (conventional for us)
	 medium-term scheduling
	    decide which processes to suspend
	       - frequently not done
	 short-term scheduling
	    decide which processes to give to the CPU next
	    a couple of milliseconds

	our job is to separate jobs between I/O bound and CPU-bound
	   I/0 Bound:
	      block frequently
	      don't use much CPU
	      should be scheduled quickly
	         ensures the CPU-bound jobs don't have to wait very long
              go to the "front" of the run queue
	   CPU-Bound
	      get pre-empted
	         make transistion from Running to Runnable
		 predictably use a lot of CPU
		 dont use other resources (significantly)
		 less likely to be interactive
		 they can stand to wait
                 go to the "end" of the run queue
       scheduling in Geekos:
          one queue, there are priorities but they are all the same

   How to create a new process?
      usulally via fork
         except to start "init"
	    first user process
	    attaches login prompts to the console
	    starts up daemons (servers)
	    reaps all orphan zombies
	       zombie is a process that is dead (no exit status)
	       orphan has no parent
         in GEEKOS, there is no "init", kernel starts shell
	    this is b/c Geekos sucks
      fork():
         return values:
	    0 - in the child
	    child_pid - in the parent
	    <0 - on error
	 prints before a fork CAN be printed by both child and parent
	    if buffer hasn't been flushed yet
	    buffer maintained in user space

   How do processes die?
      Exit()
         return from main is an example of this
      unhandled exception (i.e. SIGSEGV --> segfault, SIGPIPE)
         side note: SIGSEGV and SOME other signals can be handled
      signal from another process
         i.e. SIGKILL from shell
	 side note:
	    hierarchy of signals to use to kill a process:
	       kill -INT <proc> (same as ^C)
	       kill -HUP <proc> (tells process to try to end appropriately)
	       kill -TERM <proc> ("-TERM" is optional)
	       kill -9 <proc> (unhandleable DIE DIE DIE)

9/12 (Discussion)

   debugging:
      make "dbgrun" in one window
      make "dbg" in another
      repeats last command on "enter"
      "b file.c:LINE_NUM"
      "info threads"
      "thread apply 1 bt" (bt = backtrace)
      "thread apply all bt" (bt = backtrace)
      break on 90th iteration of loop?
         "b syscall.c:914 if count > 90"
      can't print MACROS in gdb :(
         you can create a variable to reference the MACRO if you want
      "print *struct_ptr" gives all things in struct 

9/13 (Lecture)

   the static keyword (in C)
      on a local variable: lives beyond the function's execution
      on a function defined in a header (.h) file:
         - avoids confusing the linker with multiple definitions in
	  different .o files
	 - putting a static prototype in a header is essentially useless
	 - this idea assumes the body of the function in in the header 
	 - Enable_Interrupts and Disable_Interrupts
      one a function defined in a C (.c) file:
         - avoids polluting the name space of functions (e.g. "index")
	 - asserts that a function cannot be called outside the file
	   (except via a function pointer)
	 - We can change a static keyword in GEEKOS, but be careful
	    * Don't copy and paste the code though, that's gross

   Project 1:
      What should be copied into the child process?
         two pieces of user context should change:
	    - set of pointers that define the memory space (base ptr, etc)
	       * look at userseg.c and maybe spawn.c?
	       * might be called "LDT"
	    - file descriptors should stay the same but ref count in each
	      file should change
	    - stack ptr IN user context (Neil doesn't think it's used)
	       * Maybe at the beginning, but we prob shouldn't worry
	 kthread needs a new stack, and then esp somewhere in that page 
      When a process exists, when should we free the memory?
         - we should keep the exit status
	 - it's up to us when it should actually get freed

   Inter-process communication (IPC):
     examples of IPC in use b/n processes on the same machine:
        - popen (child process) to get input
	- getting graphics to the window server
	- syslog (centralized logging service)
	   * syslog process has total control over the logs
	- process pool 
	   * coordination via shared memory
	- database
	- signals sent during shutdown or power failure

      Message passing vs. pipe:

      message passing:           	   pipe:
      message (one block)     		   byte-stream (|read| != |write|)
      per-message destination (usually)	   connected (just one other end)
      associated with microkernels	   not	   
      supposed to be very fast		   not?

      Why IPC and Processes instead of threads?
         - consider the examples of IPC list
	 - isolation
	    * if one dies the rest are fine (one can die alone)
	    * if a thread crashes it will kill everyone
	 - reuse
	    * the pager "less," other combinations from the shell
	 - different kernel-level "aspect"
	    * vary permisions/user
	    * different priorities (unsure of whether this is in threads)
	    * different set of file descriptors
	       - threads don't get their own file descriptors
	 - an idle process can be paged out (rarely used)
	 - migrate to multiple machines easily

      IPC (the ugly way):
         f = fopen("a_file.txt", "w");
	 fwrite(.....,f);
	 fclose(f);
	 ------------------------------------------------------------
	 while ((f=fopen("a_file.txt", "r"))==NULL) {
	     sleep(1);
	 }
	 fread(...); 

	 - essentially how compiler communicates with linker

      Shared memory approach:
         - not done in GEEKOS
	 - imagine two processes with independent virtual address spaces
	    * imagine they have unique stacks in physical memory
	    * they both have a shared code segment in physical memory
	 - they could have a shared memory region
	    * not necessarily at the same point in their individual
	      virtual address space
	    * both point to the same point in physical memory
	 - very fast, no communication through kernel necessary
	 - the shared code-segment is different
	    * mapping the same read-only page does not amount to 
	      "shared-memory" IPC
	 - if you fork, the top of the stack points to the same point
	   until one is attempted to be written to, at which point the
	   one written two will be allocated a new read-allowed page
	 - interface for this:
	    * shmget - may create
	    * shmctl - sets permissions
	    * shmat - "open"
	    * shmdt - "close"
	 - essentially we want a pipe like scheme for the shared memory
	 - how do we coordinate this shared memory?
	    * partition
	       - using software, decide which process should write which
	         part of the shared memory (set flags for read/write)
	    * sequence number
	       - define each message as having #, length, and body
	       - let's say 1 is writing, 2 is reading
	       - 2 keeps track of the last # read
	       - assuming they are sequential (or ordered in some way)
	         2 can appropriately know which to read
	       - 2 can have an int that allows 1 to know when the writer
	         can delete already read messages
	    * semaphore, mutex, condition variable, etc.

9/14 (Discussion)

   Project 1: Fork
      LDT (Local Descriptor Table):
         This should be handled by create_context
	 I don't think we need to worry about anything more than copying it over
      start_user_process vs. creating your own?
         probably use built-in over user-created, but it's really up to you
      user_context -> memory
         allocated by built-in functions I believe
	 you can copy this for forking, probably not for exec-ing though

      state pointer will point to beginning of "interrupt state" struct always
         esp not as reliable

      poke around in kthread.c
         create_thread and whatnot

      copying the kernel stack?
         maybe disable interrupts? not sure about that
         "copy" interrupt state
	    copy what you KNOW will still be there from the kernel stack
	 for exec, changing eip might be advised

      kernel thread also has a reference count
         initial reference count is 2 after fork (parent AND child)
	 be careful for non-waiting parents
	    i.e. children waiting count will be 1 if no waiting parent

      git notes:
         you should commit frequently, push less frequently
	 git status
	 git log
	 git branch "test_name"
	    git checkout "test_name"
	 git checkout "commit number"
	 git reset --hard "commit number" HEAD~n
	    completely deletes "n" most recent commits
	 git revert Head~n
	    revert previous "n" commits but keeps history

9/15 (lecture)

   Fork is not recursive
      - fork provides an interface to user code, but the child process starts as if new

   Make_Runnable -> sticks child on run queue

   To go to Running, Handle_Interrupt will do this (from Runnable)
      Handle_Interrupt always calls GetNextRunnable	 

   At the top of the kernel's (parent) stack:
      Interrupt_State (all the registers)

   kthreaad->esp should be set to state initially
      pretty much only valid for this purpose (doesn't necessarily get updated w/ actual
      esp)

   The address at the bottom of the stack page
      something like (0x00034000)
         3 zeros at end, a couple at beginning
      therefore, at all times 
         KASSERT((kthread->esp) & 0xFFFFF000 == kthread->stackPage)

   user_context vs. kthread stack?

   Sockets:
      Unix Sockets
         - on the same machine
	 - allows extra information and trust
	    * what user owns the other process?	 
	 - you can pass an open file through the socket
	 - on the same machine, this is probably more efficient
      IP Sockets
         - network communcation
	 - really can only know the address of the other endpoint

      Datagrams
         - messages
	 - packets (UDP: User Datagram Protocol)
	 - might not be "connected"
	    * you may specify the destination with every message (sendto())
      Bytestreams
         - sequence of bytes (TCP)
	 - connected
	 - similar to pipe

      socket() 
         - creates a socket
	 - returns a file descriptor
	 - tells the kernel the type you want (Unix, bytestream, etc.)

      SERVER SIDE:

      bind()
         - specifies the endpoint associated with a socket
	 - endpoint will probably be a path for Unix
	 - "	    	 	  "  a TCP Port for IP
	 - if the caller doesn't specificy the port, one will be allocated for you

      listen()
         - express a willingness to accept connections

      accept()
         - takes a file "listening" descriptor
	 - returns a new file descriptor for an incoming connection

      CLIENT SIDE:

      connect()
         - specifies a remote endpoint for the socket
	 - bytestream -> connection setup request
	 - datagram -> set the implicit destination

      OTHER SOCKET FUNCTIONS:
         read/recv/recvfrom
      	 write/send/sendto
      	 close
	 shutdown()
	    - I am done writing
	    - I am done reading
	    - I am done with both

      Threads:
         - shared address space
	 - own stack
	    * call pthread_create and what happens?
	       - malloc a new area beneath the first stack
	       - no virtual memory trickery
	    * what happens when a function from a pthread returns?
	       - return address to some routine that will keep EAX for later pthread_join
	 - threads are hard to debug because of shared address space

9/19 (Discussion)

   Project 1:
      you probably don't want to use a global lock for pipes
      don't worry about synchronization on other types of files (not pipes)
      Don't assume atomicity

9/20 (Lecture)

     Project 1:
          User process address space
	     stack at the end of user process address space
	     command line args must be put on the user stack
	        two parameters to main:
		   argc and argv
		argv pushed onto user stack frame, followed by argc pushed
		   after those, return address is pushed onto stack
		   after that, old ebp is pushed
		where do the strings that argv points to go?
		   doesn't really matter (we have a pointer)
		   however they are generaly put right above the stack

          Register Dump:
	     What to do with Exception 13?
	        Machine tried to look at pointer it shouldn't
	     Which registers matter?
	        eip:
		   if in range 0x1000-0x3000 -> likely valid user instruction address
		   if in range 0x10000-0x40000 -> likely valid kernel instruction address

		   How to figure out what eip really is?
		      in make dbg
		         can run "dis (eip)"
			    gives which function and what instruction
		      "sort -n build/geekos/kernel.syms"
		         gives you the function
			 
                 Interrupt number 6:
		    not really an instruction (or not one can be run in this privilege)
         in gdb:
	    x /100 0x000bfcda
	       command to examine amount of memory regardless of type
	    thread apply all bt
	       similar to single threaded "where"

   setjmp(buffer)
      creates an image of current context, sticks it into buffer
         includes register state, eip, etc.
      store current context (registers and such) into a buffer
      will return differnt value the first time   

   longjmp(buffer)
      jump back to state represented by buffer
      restor a stored context (jumping far)

   linked-list of runnable threads
      in each node is info about thread (start ptr, args, ret) and buffer
      
   we use setjmp to save current state and put it on thread queue
      then longjmp to new buffer for new thread

   User-Level Threads:
      kernel knows nothing about them
      advantages:
         user has control over scheduling and can avoid bad interactions
	 very fast creation/destruction of threads
      disadvantages:
         can't use multiple processors
	 complexity in avoiding blocking system calls

   How many kernel threads should you have?
      number of processors?
      expected number of blocked threads
         if large:
	    probably better to do something else
	    don't block

9/21 (Discussion)

   Project 1:
      run while(Fork()>=0);
         if you can return to shell and run stuff after this you're good
      kill unwaited-on child
         each kthread has a "parent" field?
	 add a field to kthread? (at bottom)
      you want a new ldt for child

   Project 2: Signals

9/21 (Personal Notes)

   Descriptor gives:
      base address
      limit address
      privilege
      type (read,write,etc)

   Selector gives:
      GDT vs. LDT
      Privilege Mode
      Index in G/LDT
