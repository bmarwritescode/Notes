8/29 (Discussion)

int * const blah --> the pointer cannot be changed
const int *blah  --> the pointer is to a const int
            
consider:
	arr = {1,2,3,4,5}
	a = arr
	c = a
	
	++*a;        --> dereferences a and then increments that value
	*a++         --> dereferences a and then increments the pointer
	*c = (*a)++; --> adds dereferenced c and a, then increments a 

For macros, consider this:
    #define MULT(a,b) (a * b)
    	    --> This does NOT work with MULT(1+2,3+4) OOP
Try instead:
    #define MULT(a,b) ((a) * (b))

gcc -D SAMPLE --> defines the given macro SAMPLE

gcc -E --> will show code after preprocessing

8/30 (Lecture)

intro stuff

8/31 (Discussion)

vagrant up --> initialize vm
vagrant ssh --> get into vm
cd /vagrant is a shared file (really wherever you run VM from becomes the 
 vagrant directory)
 	 you should run vagrant ssh from the project folder
vagrant destroy (you might lose local changes WITHIN the vm not in shared dir)
vagrant halt --> will shutdown VM instance but not remove from disk
	Both use "vagrant up" to start back up
You can run GeekOS from both local machine and VM

kassert can be helpful for finding errors

gdb: watch variable tracks variable changes
     conditional breaks

9/6 (Lecture)

Project 1: Fork and exec

   After fork, we have 2 user processes (user address space)
      Each has a unique Kernel_Thread (KT)
         Each KT has its own Stack -> you must decide what Stack is inherited
            Each KT has a unique userContext (UC)
               Each has an individual set of file descriptors (FD)
	          Each FD points into the same File Descriptor Table (FDT)
      Global variables start out the same, but are updated separately
      EIP is copied into new process
      Spawn (maybe in user.c or userseg.c) has most of what we need	    
      In GEEKOS, no stdin, stdout, stderr

User Process vs. Kernel
   Process believes it has its own CPU
   Process essentially believes there is infinite memory
   Process believes there are "files" and "directories"
   Process believes there is "Wall" between it and other processes
   IPC - Inter-Process-Communication
      pipe, signal, shared memory, message passing, network sockets

Virtual Memory
   Any time the address in a register is different from the physical address
   Can be used to provide illusion of more space
   0xfffffff
   ________
   stack (grows down)
   ________
   heap (grows up)
   ________
   data
   ________
   txt
   ________

   ________
   0x00000000	

   segmentation allows >1 instances of the same program
   nm (executable) -> shows addresses of all symbols in executable
      first usable page starts at 0x1000 because we want 0 to be reserved
      for Null

Pointer Alignment
   (int *) -> should be 4-byte aligned
      should be a multiple of 4
   (char *) -> should be 1-byte aligned
      should be a multiple of 1
   consider:
      struct foo {int a; char b; int c;};
         sizeof(foo) = 12 bytes (not 9 due to int 4-byte alignment)

9/7 (Discussion)

   Project 0:
      Ensure that everything is appropriately freed in Close
         Try a test that repeatedly calls Pipe and Close

   Project 1:
      Mutex will probably be the way to go		
      Take a look at Spawn (in user.c)
         Spawn unsurprisingly Spawns a user process      
      Each process has a kernel_thread associated with it
         Each of these has a user_context
      Jump around k_thread struct and User_Context struct (user.h)
      Also Sys_Spawn -> look here also
      Mutex in sync.c (I think)

   gdb notes:
      run "make dbg run;make dbg"
      b "Sys_Spawn" --> breakpoing at Sys_Spawn function 
      s -> step into
      n -> step over
      c -> keep going till next breakpoint
      printx --> print variable in hex
      struct notation from c still works for print

9/8 (Lecture)

   Project 0: 
      Too much output being printed by students
         try :
            fn() {
      	       static int ive_complain;

	       if (!ive_complained) {
	          Print("waaa!");
	          ive_complained = 1;
	       }
	fixed size buffer:
	   allocate little buffers in a list
	   allocate a single buffer and shift/advance (I shift)
	      advance would probably be better, but I should check changes
	      for shift I should use memmove, not memcpy

   Process States:
      Running:
         to get to Waiting:
	    waiting for input(device)? child process to terminate? mutex?
	 to get to Runnable:
	    dispatcher (I think) can force an active process into the run queue
      Runnable:
         to get to Running:
	    piece of software (dispatcher) pops process off of run queue
      Waiting (Blocked):
         to get to Runnable:
	    when the thing we were waiting for happens
	    (unblocked/awakened from the wait queue)

      for all process in Runnable (on run queue):
         how do we decide which to run?
	 how do we manage the Run Queue?
	    - priorities on processes
	       * most complex last
	       * how long it's been waiting
	          - longer waits first, avoid starvation
	       * how much longer it will run
	          - longer run last, allow short jobs responsive
		  - can we do this? (external spec?, predicter?)
	       * how much resources it will use
	          - can be useful in event of conflict on resources
		  - possible justification to suspend process
	       * solving priority inversion
	          - priority inversion
		     * parent important, calls wait on child
		     * child not important (doesn't fit above criteria)
		     * high priority waiting on low priority
		  - possibly temporarily bump up a low priority process
	       * Avoiding starvation is particularly important
	       * Allowing short commands to be responsive is also important

      Scheduler (three levels):
         long-term scheduling:	
	    deciding which process to run (or really start) 
	       - associated with "batch"
	          * old-school approach when punch cards were a thing
		  * finish one process, move onto the next
		  * as opposed to time-sharing
		     - we start a job whenever we want (conventional for us)
	 medium-term scheduling
	    decide which processes to suspend
	       - frequently not done
	 short-term scheduling
	    decide which processes to give to the CPU next
	    a couple of milliseconds

	our job is to separate jobs between I/O bound and CPU-bound
	   I/0 Bound:
	      block frequently
	      don't use much CPU
	      should be scheduled quickly
	         ensures the CPU-bound jobs don't have to wait very long
              go to the "front" of the run queue
	   CPU-Bound
	      get pre-empted
	         make transistion from Running to Runnable
		 predictably use a lot of CPU
		 dont use other resources (significantly)
		 less likely to be interactive
		 they can stand to wait
                 go to the "end" of the run queue
       scheduling in Geekos:
          one queue, there are priorities but they are all the same

   How to create a new process?
      usulally via fork
         except to start "init"
	    first user process
	    attaches login prompts to the console
	    starts up daemons (servers)
	    reaps all orphan zombies
	       zombie is a process that is dead (no exit status)
	       orphan has no parent
         in GEEKOS, there is no "init", kernel starts shell
	    this is b/c Geekos sucks
      fork():
         return values:
	    0 - in the child
	    child_pid - in the parent
	    <0 - on error
	 prints before a fork CAN be printed by both child and parent
	    if buffer hasn't been flushed yet
	    buffer maintained in user space

   How do processes die?
      Exit()
         return from main is an example of this
      unhandled exception (i.e. SIGSEGV --> segfault, SIGPIPE)
         side note: SIGSEGV and SOME other signals can be handled
      signal from another process
         i.e. SIGKILL from shell
	 side note:
	    hierarchy of signals to use to kill a process:
	       kill -INT <proc> (same as ^C)
	       kill -HUP <proc> (tells process to try to end appropriately)
	       kill -TERM <proc> ("-TERM" is optional)
	       kill -9 <proc> (unhandleable DIE DIE DIE)

9/12 (Discussion)

   debugging:
      make "dbgrun" in one window
      make "dbg" in another
      repeats last command on "enter"
      "b file.c:LINE_NUM"
      "info threads"
      "thread apply 1 bt" (bt = backtrace)
      "thread apply all bt" (bt = backtrace)
      break on 90th iteration of loop?
         "b syscall.c:914 if count > 90"
      can't print MACROS in gdb :(
         you can create a variable to reference the MACRO if you want
      "print *struct_ptr" gives all things in struct 