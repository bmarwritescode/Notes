8/29 (Discussion)

int * const blah --> the pointer cannot be changed
const int *blah  --> the pointer is to a const int

consider:
	arr = {1,2,3,4,5}
	a = arr
	c = a
	
	++*a;        --> dereferences a and then increments that value
	*a++         --> dereferences a and then increments the pointer
	*c = (*a)++; --> adds dereferenced c and a, then increments a 

For macros, consider this:
    #define MULT(a,b) (a * b)
    	    --> This does NOT work with MULT(1+2,3+4) OOP
Try instead:
    #define MULT(a,b) ((a) * (b))

gcc -D SAMPLE --> defines the given macro SAMPLE

gcc -E --> will show code after preprocessing

8/30 (Lecture)

intro stuff

8/31 (Discussion)

vagrant up --> initialize vm
vagrant ssh --> get into vm
cd /vagrant is a shared file (really wherever you run VM from becomes the 
 vagrant directory)
 	 you should run vagrant ssh from the project folder
vagrant destroy (you might lose local changes WITHIN the vm not in shared dir)
vagrant halt --> will shutdown VM instance but not remove from disk
	Both use "vagrant up" to start back up
You can run GeekOS from both local machine and VM

kassert can be helpful for finding errors

gdb: watch variable tracks variable changes
     conditional breaks

9/6 (Lecture)

Project 1: Fork and exec

   After fork, we have 2 user processes (user address space)
      Each has a unique Kernel_Thread (KT)
         Each KT has its own Stack -> you must decide what Stack is inherited
            Each KT has a unique userContext (UC)
               Each has an individual set of file descriptors (FD)
	          Each FD points into the same File Descriptor Table (FDT)
      Global variables start out the same, but are updated separately
      EIP is copied into new process
      Spawn (maybe in user.c or userseg.c) has most of what we need	    
      In GEEKOS, no stdin, stdout, stderr

User Process vs. Kernel
   Process believes it has its own CPU
   Process essentially believes there is infinite memory
   Process believes there are "files" and "directories"
   Process believes there is "Wall" between it and other processes
   IPC - Inter-Process-Communication
      pipe, signal, shared memory, message passing, network sockets

Virtual Memory
   Any time the address in a register is different from the physical address
   Can be used to provide illusion of more space
   0xfffffff
   ________
   stack (grows down)
   ________
   heap (grows up)
   ________
   data
   ________
   txt
   ________

   ________
   0x00000000	

   segmentation allows >1 instances of the same program
   nm (executable) -> shows addresses of all symbols in executable
      first usable page starts at 0x1000 because we want 0 to be reserved
      for Null

Pointer Alignment
   (int *) -> should be 4-byte aligned
      should be a multiple of 4
   (char *) -> should be 1-byte aligned
      should be a multiple of 1
   consider:
      struct foo {int a; char b; int c;};
         sizeof(foo) = 12 bytes (not 9 due to int 4-byte alignment)