8/29

OCaml review:
      let add (x,y) = x+y;;
      	  int * int -> int
      let add x y = x+y;;
      	  int -> int -> int
	      (add 1) returns a funtion that adds 1 to a number
      let twice g x = g (g x);;
      	  ('a -> 'a) -> 'a -> 'a
      remember lists separated by semicolon [1,2,3] != [1;2;3]
      remember "rec" modifier to allow for recursion
      "_" replaces an unused part in a pattern match
      "function" like "fun" but automatically takes argument and pattern match
      Records:
	type course = {title:string; num:int}
	let x = {title="blah"; num=1234}
	x.num;; --> dot notation
	{x with num=431} --> can be used to set defaults
	by default, records are immutable
	   this can be changed as shown:
	   	type course = {title:"blah"; mutable int:1234}
	   then:
		x.num <- 430;;
      	Example:
	   	type course = {title:"blah"; mutable int:1234}
		let x = {title="blah"; num=1234}     
		Let w = {x with title="meh"}
		x.num <- 433
		What HAPPENS?

      References "ref":
      		 let x = ref 1;;
		     basically let x = {mutable contents=1}
      Shadowing:
	reusing a variable name causes a previous definition to be overwritten

      Type annotation (add a :TYPE after a variable to restrict its type)
      Nominal typing -> types distinguished by name, REGARDLESS of content
      
      Arrays:
	let x = [|4;2;3|]
	x.(0) <- 1
	MUTABLE!!
      Strings:
	Essentially arrays (which means theyre mutable)

      OCAML:
	Tuples
	Lists
	Records
	Arrays
	User-defined Data types (trees)

      Ruby:
        Array
	Hash (not built into OCaml -> interesting
	
      '_a -> this type implies that a mutable value of anuy type can be used, 
      	  but once it is it must remain of that type

8/31

   Syntax (language structure) vs. semantics (actual meaning)
   list.assoc will be helpful for project list of vars
   OCaml option type: Some vs. None (essentially NULL for OCaml)
   Project 1: for bvec, higher order bits to the right
   	      make sure to compile projects, not run them top level
   OCaml Review cont.:
      let f ~x ~y = x-y (named arguments to function)
         we can do:
	    f 4 3;;
	    f ~y:4 ~x:3
	 (in order to work, you must name all or no variables)
      
      Currying:
         create partial functions (partial application)
	 let add x y = x+y;;
	 let g = add 1;; (now we have an add 1 function)
	 More difficult to replace second argument:
	    achieved using named arguments
      
      Loops:
	 let rec foo() = foo();; --> never dies because of tail recursion
	 while true do () done;; --> internally turned into let rec w/ tail rec
	 there also exists a for loop implementation
      
      Modules:
         module type BLAH = 
	    sig
	      type blah
	      val hmm : blah -> int
	 end;;
	 
	 Note: the two semicolons and the next part are largely unnecessary for
	       compiled OCaml

	 module Blah : BLAH = 
	    struct
	       let hmm b = 0;;
	    end

	 consider the module Set (also consider module Hash_tbl)
	    functr is a function that takes modules and gives you new modules

	 Polymorphic Variants: 
	    [`On; `Off];;
	    [> `Off | `On] --> list of eith Off or On
	    `Number 1;;
	    let f x = match x with
	    [< `Number of int | `On | `Off]
	    `On -> 1
	    | `Off -> 0
	    | `Number n -> n;;

	    You could do something like:
	       `Number;; (You could do this with an explicitly defined type)
	    [> --> this means it has at LEAST the following types
	    [< --> this means it has at MOST the following types
	    Tradeoff: flexibility vs. compile-time check
	    Useful for stuff like:
	       f takes `A, `B, and `C
	       g takes `B, `C, and `D

9/7

   Project 1:
      lambda(x).y [replace y --> x]
         the x from lambda x is meaningless -> similar to:
	    int foo(int x) {
	       return x;
	    }
	 you can just rename x as z --> essentially alpha conversion
	 lambda(x).y --> lambda(z).y
	 therefore [replace y --> x] gives:
	    lambda(z).x which is essentially the same as lambda(x).x
	       just less confusing
      you won't lose any points for extra tests (make many)
      "open Module" --> don't have to write Module. notation
         List.assoc;;
	 open List;;
	 assoc;;
      testing sat? --> buggy in "natural ways"

   Parsing:
      Compiler -> two parts: front end vs. back end
	 source code-->lexer-->parser-->types-->AST--->...-->machine code
	 [-------------Front End------------------][------Back End ------]

	 More research into Front End --> not sure why

         lexer - creates tokens (terminals of language)
	    terminals:
	       identifier, integer
	       ex:
	          type expt = 
		     EFalse
		  |  False
	       type, =, | --> 
	       EFalse, False --> identifiers
	    uses regular expressions
	 parser - 
	    uses Context Free Grammars

	 Why this difference?
	    Regexp is really fast (so it's done first)
	       might be able to catch basic syntax mistakes/errors

	 Abstract Syntax Tree vs. Parse Tree:
	    Parse Tree is very similar but has more fluff (parentheses)
	    consider:
	       a ^ b v c vs. (a ^ b) v c vs. a ^ (b v c)
	    AST don't need this because it is clear from the structure of the
	       tree 

      Parsing Algorithms:
         General purpose algorithms: CYK and Earley (generally considered impractical)
	 they can deal with any CFG (yay) but slow
	 More practical algorithms:
	    LL(k): (ANTLR)
	       top-down parser
	          parses from top of parse tree to bottom
	       left-to-right
	       left-most-derivation
	          Always looks at left-most non-terminal to reduce first
	    Consider:
	       S -> AA
	       A -> a
	    Derivation - start from first symbol all the way to a string
	       S -> AA -> aA -> aa (left-most)
	       S -> AA -> Aa -> aa (right-most)
	    top-down-parser:
	       parses from S to aa (separates S -> AA -> aa
	    LR(k): (yacc)
	       bottum-up parsing
	          parses from bottom of parse tree
	       left-to-right
	       right-most-derivation
	    yacc: (lexer = lex)
	       different versions for different languages
	          bison (for c), ocamlyacc (for ocaml)
		  tied to lexers: flex and ocamllex respectively
		  
      Let's build a parser for arithmetic expressions:
         E -> E+E | n | (E)
	    where n is an arbitrary integer
	    what are tokens? "+", "(", ")", "n"
	    maybe we want whitespace? (lexer removes whitespace, comments, newlines, etc)
	 .mll extension for ocamllex
	 token lexbuf -> can remove unneeded things (whitespace, tabs, etc)
	 run ocamllex on .mll file creates (compiles) a .ml file
	    .ml is a table-driven finite automaton
	 rule token = parse
	    creates recursive function token that essentially does automata traversal
	 Lexing.engine -> ocaml module worth looking at
	 parser will take:
	    1+2+3
	    creates lexbuf (input string with pos in string)
	    calls token lexbuf which retrieves next token
	       Int(1), Plus, Int(2), Plus, Int(3), EOL
	 for parser, if any of the regexp overlap, ocaml will probably match the first
	 finite automata has limited number of states
	 parse string for:
	    1+2+3
	    Grammar is ambiguous: there are two possible parse trees
	 Let's consider instead:
	    E -> T | E + T
	    T -> n | (E)
	    no longer ambiguous
	    E
	    (E+T)
	    (E+T)(+)(3)
	    (T)(+)(T)(+)(3)
	 .mly file defines the parser
	    %token at beginning define tokens used by lexer
	    %start defines start symbol of grammar
	    generally terminals are uppercase, non-terminals are lowercase
	       opposite of how we generally write it
	 run .mly with ocamlyacc
	    we get .mli file and a .ml file
	 start symbol of grammar becomes name of function in .mli
	 .ml file:
	    there are many tables (table-driven file)
	    Parsing.yyparse -> ocaml standard library
	 Our goal is to produce AST
	 Every production has a given value (andtype)
	    {$1} in the .mli file

      Derivation
      Leftmost/rightmost
      sentential form
         E -> E+E -> n+E -> n+n (each thing separated by "->" is a sentential form)
      FIRST(alpha) - set of potential first characters
         S -> a | B | Bc |Df
	 B -> b
	 D -> d | empty
         First(S) = {a,b,d,f}

      if we have x,y where x,y are collections of terminals
         we want to go all the way backwards to S (starting symbol of grammar)
	 xy -> aby -> aBy -> ABy -> ... -> S
	 production goes from B->a, reduction goes from a->B
	 If there exists only one parse tree, there is only one left and right most derivation
	    maybe there's some hope for us
